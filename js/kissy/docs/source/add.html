<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * @ignore
 * @fileOverview add module to kissy simple loader
 * @author yiminghe@gmail.com, lifesinger@gmail.com
 */
(function (S, undefined) {

    var Loader = S.Loader,
        Path = S.Path,
        utils = Loader.Utils;


    S.augment(Loader,
        Loader.Target,
        {

            //firefox,ie9,chrome 如果 add 没有模块名，模块定义先暂存这里
            __currentModule: null,

            //ie6,7,8开始载入脚本的时间
            __startLoadTime: 0,

            //ie6,7,8开始载入脚本对应的模块名
            __startLoadModuleName: null,

<span id='KISSY-Loader-method-add'>            /**
</span>             * Registers a module.
             * @param {String|Object} [name] module name
             * @param {Function|Object} [fn] entry point into the module that is used to bind module to KISSY
             * @param {Object} [config] special config for this add
             * @param {String[]} [config.requires] array of mod's name that current module requires
             * @member KISSY.Loader
             *
             * for example:
             *      @example
             *      KISSY.add('module-name', function(S){ }, {requires: ['mod1']});
             */
            add: function (name, fn, config) {
                var self = this,
                    runtime = self.runtime,
                    mod,
                    requires,
                    mods = runtime.Env.mods;

                // 兼容
                if (S.isPlainObject(name)) {
                    return runtime.config({
                        modules: name
                    });
                }

                // S.add(name[, fn[, config]])
                if (typeof name == 'string') {

                    utils.registerModule(runtime, name, fn, config);

                    mod = mods[name];

                    // 显示指定 add 不 attach
                    if (config &amp;&amp; config['attach'] === false) {
                        return;
                    }

                    if (config) {
                        requires = mod.getNormalizedRequires();
                    }

                    if (!requires || utils.isAttached(runtime, requires)) {
                        utils.attachMod(runtime, mod);
                    }

                    return;
                }
                // S.add(fn,config);
                else if (S.isFunction(name)) {
                    config = fn;
                    fn = name;
                    if (utils.IE) {
                        /*
                         Kris Zyp
                         2010年10月21日, 上午11时34分
                         We actually had some discussions off-list, as it turns out the required
                         technique is a little different than described in this thread. Briefly,
                         to identify anonymous modules from scripts:
                         * In non-IE browsers, the onload event is sufficient, it always fires
                         immediately after the script is executed.
                         * In IE, if the script is in the cache, it actually executes *during*
                         the DOM insertion of the script tag, so you can keep track of which
                         script is being requested in case define() is called during the DOM
                         insertion.
                         * In IE, if the script is not in the cache, when define() is called you
                         can iterate through the script tags and the currently executing one will
                         have a script.readyState == 'interactive'
                         See RequireJS source code if you need more hints.
                         Anyway, the bottom line from a spec perspective is that it is
                         implemented, it works, and it is possible. Hope that helps.
                         Kris
                         */
                        // http://groups.google.com/group/commonjs/browse_thread/thread/5a3358ece35e688e/43145ceccfb1dc02#43145ceccfb1dc02
                        // use onload to get module name is not right in ie
                        name = findModuleNameByInteractive(self);
                        S.log('old_ie get modName by interactive : ' + name);
                        utils.registerModule(runtime, name, fn, config);
                        self.__startLoadModuleName = null;
                        self.__startLoadTime = 0;
                    } else {
                        // 其他浏览器 onload 时，关联模块名与模块定义
                        self.__currentModule = {
                            fn: fn,
                            config: config
                        };
                    }
                    return;
                }
                S.log('invalid format for KISSY.add !', 'error');
            }
        });


    // ie 特有，找到当前正在交互的脚本，根据脚本名确定模块名
    // 如果找不到，返回发送前那个脚本
    function findModuleNameByInteractive(self) {
        var runtime = self.runtime,
            scripts = S.Env.host.document.getElementsByTagName('script'),
            re,
            i,
            script;

        for (i = 0; i &lt; scripts.length; i++) {
            script = scripts[i];
            if (script.readyState == 'interactive') {
                re = script;
                break;
            }
        }
        if (!re) {
            // sometimes when read module file from cache , interactive status is not triggered
            // module code is executed right after inserting into dom
            // i has to preserve module name before insert module script into dom , then get it back here
            S.log('can not find interactive script,time diff : ' + (+new Date() - self.__startLoadTime), 'error');
            S.log('old_ie get mod name from cache : ' + self.__startLoadModuleName);
            return self.__startLoadModuleName;
        }

        // src 必定是绝对路径
        // or re.hasAttribute ? re.src :  re.getAttribute('src', 4);
        // http://msdn.microsoft.com/en-us/library/ms536429(VS.85).aspx
        // note:
        // &lt;script src='/x.js'&gt;&lt;/script&gt;
        // ie6-8 =&gt; re.src == '/x.js'
        // ie9 or firefox/chrome =&gt; re.src == 'http://localhost/x.js'
        var src = utils.resolveByPage(re.src),
            srcStr = src.toString(),
            packages = runtime.config('packages'),
            finalPackagePath,
            p,
            packageBase,
            Config = runtime.Config,
            finalPackageUri,
            finalPackageLength = -1;

        // 外部模块去除包路径，得到模块名
        for (p in packages) {

            packageBase = packages[p].getBase();
            if (S.startsWith(srcStr, packageBase)) {
                // longest match
                if (packageBase.length &gt; finalPackageLength) {
                    finalPackageLength = packageBase.length;
                    finalPackagePath = packageBase;
                    finalPackageUri = packages[p].getBaseUri();
                }
            }

        }
        // 注意：模块名不包含后缀名以及参数，所以去除
        // 系统模块去除系统路径
        // 需要 base norm , 防止 base 被指定为相对路径
        // configs 统一处理
        if (finalPackagePath) {
            return utils.removeExtname(Path.relative(finalPackageUri.getPath(),
                src.getPath()));
        } else if (S.startsWith(srcStr, Config.base)) {
            return utils.removeExtname(Path.relative(Config.baseUri.getPath(),
                src.getPath()));
        }

        S.log('interactive script does not have package config ：' + src, 'error');
        return undefined;
    }

})(KISSY);

/*
 2012-02-21 yiminghe@gmail.com refactor:

 拆分 ComboLoader 与 Loader

 2011-01-04 chengyu&lt;yiminghe@gmail.com&gt; refactor:

 adopt requirejs :

 1. packages(cfg) , cfg :{
 name : 包名，用于指定业务模块前缀
 path: 前缀包名对应的路径
 charset: 该包下所有文件的编码

 2. add(moduleName,function(S,depModule){return function(){}},{requires:['depModuleName']});
 moduleName add 时可以不写
 depModuleName 可以写相对地址 (./ , ../)，相对于 moduleName

 3. S.use(['dom'],function(S,DOM){
 });
 依赖注入，发生于 add 和 use 时期

 4. add,use 不支持 css loader ,getScript 仍然保留支持

 5. 部分更新模块文件代码 x/y?t=2011 ，加载过程中注意去除事件戳，仅在载入文件时使用

 demo : http://lite-ext.googlecode.com/svn/trunk/lite-ext/playground/module_package/index.html

 2011-03-01 yiminghe@gmail.com note:

 compatibility

 1. 保持兼容性
 如果 requires 都已经 attached，支持 add 后立即 attach
 支持 { attach : false } 显示控制 add 时是否 attach

 2011-05-04 初步拆分文件，tmd 乱了
 */
</pre>
</body>
</html>
